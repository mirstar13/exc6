// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addGroupMember = `-- name: AddGroupMember :one
INSERT INTO group_members (group_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING id, group_id, user_id, role, joined_at
`

type AddGroupMemberParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
	Role    string
}

func (q *Queries) AddGroupMember(ctx context.Context, arg AddGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, addGroupMember, arg.GroupID, arg.UserID, arg.Role)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (name, description, icon, custom_icon, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, icon, custom_icon, created_by, created_at, updated_at
`

type CreateGroupParams struct {
	Name        string
	Description sql.NullString
	Icon        sql.NullString
	CustomIcon  sql.NullString
	CreatedBy   uuid.UUID
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.CustomIcon,
		arg.CreatedBy,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CustomIcon,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :one
DELETE FROM groups WHERE id = $1
RETURNING id, name, description, icon, custom_icon, created_by, created_at, updated_at
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) (Group, error) {
	row := q.db.QueryRowContext(ctx, deleteGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CustomIcon,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT id, name, description, icon, custom_icon, created_by, created_at, updated_at FROM groups WHERE id = $1
`

func (q *Queries) GetGroupByID(ctx context.Context, id uuid.UUID) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CustomIcon,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupMember = `-- name: GetGroupMember :one
SELECT id, group_id, user_id, role, joined_at FROM group_members
WHERE group_id = $1 AND user_id = $2
`

type GetGroupMemberParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) GetGroupMember(ctx context.Context, arg GetGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, getGroupMember, arg.GroupID, arg.UserID)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const getGroupMemberCount = `-- name: GetGroupMemberCount :one
SELECT COUNT(*) FROM group_members WHERE group_id = $1
`

func (q *Queries) GetGroupMemberCount(ctx context.Context, groupID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGroupMemberCount, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGroupMembers = `-- name: GetGroupMembers :many
SELECT u.id, u.username, u.icon, u.custom_icon, gm.role, gm.joined_at
FROM group_members gm
INNER JOIN users u ON gm.user_id = u.id
WHERE gm.group_id = $1
ORDER BY gm.joined_at
`

type GetGroupMembersRow struct {
	ID         uuid.UUID
	Username   string
	Icon       sql.NullString
	CustomIcon sql.NullString
	Role       string
	JoinedAt   time.Time
}

func (q *Queries) GetGroupMembers(ctx context.Context, groupID uuid.UUID) ([]GetGroupMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMembersRow
	for rows.Next() {
		var i GetGroupMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Icon,
			&i.CustomIcon,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGroups = `-- name: GetUserGroups :many
SELECT g.id, g.name, g.description, g.icon, g.custom_icon, g.created_by, g.created_at, g.updated_at FROM groups g
INNER JOIN group_members gm ON g.id = gm.group_id
WHERE gm.user_id = $1
ORDER BY g.updated_at DESC
`

func (q *Queries) GetUserGroups(ctx context.Context, userID uuid.UUID) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.CustomIcon,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isGroupAdmin = `-- name: IsGroupAdmin :one
SELECT EXISTS(
    SELECT 1 FROM group_members
    WHERE group_id = $1 AND user_id = $2 AND role = 'admin'
) AS is_admin
`

type IsGroupAdminParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) IsGroupAdmin(ctx context.Context, arg IsGroupAdminParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isGroupAdmin, arg.GroupID, arg.UserID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isGroupMember = `-- name: IsGroupMember :one
SELECT EXISTS(
    SELECT 1 FROM group_members
    WHERE group_id = $1 AND user_id = $2
) AS is_member
`

type IsGroupMemberParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) IsGroupMember(ctx context.Context, arg IsGroupMemberParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isGroupMember, arg.GroupID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const removeGroupMember = `-- name: RemoveGroupMember :one
DELETE FROM group_members
WHERE group_id = $1 AND user_id = $2
RETURNING id, group_id, user_id, role, joined_at
`

type RemoveGroupMemberParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) RemoveGroupMember(ctx context.Context, arg RemoveGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, removeGroupMember, arg.GroupID, arg.UserID)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET name = $2, description = $3, icon = $4, custom_icon = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, icon, custom_icon, created_by, created_at, updated_at
`

type UpdateGroupParams struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	Icon        sql.NullString
	CustomIcon  sql.NullString
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, updateGroup,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.CustomIcon,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.CustomIcon,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberRole = `-- name: UpdateMemberRole :one
UPDATE group_members
SET role = $3
WHERE group_id = $1 AND user_id = $2
RETURNING id, group_id, user_id, role, joined_at
`

type UpdateMemberRoleParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
	Role    string
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, updateMemberRole, arg.GroupID, arg.UserID, arg.Role)
	var i GroupMember
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}
